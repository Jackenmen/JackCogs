import asyncio
import datetime

from typing import Any, Optional, Union, TypeVar, Generic, Type, Awaitable, Generator, Callable
from typing_extensions import Final

MAX_ASYNCIO_SECONDS: Final[int]

_T = TypeVar('_T')
_L = TypeVar('_L', bound=Loop)
_CoroType = Callable[..., Union[Awaitable[_T], Generator[Any, None, _T]]]
_C = TypeVar('_C', bound=Callable[..., Awaitable[Any]])

class Loop(Generic[_T]):
    coro: _CoroType[_T] = ...
    seconds: float = ...
    hours: float = ...
    minutes: float = ...
    reconnect: bool = ...
    loop: asyncio.AbstractEventLoop = ...
    count: Optional[int] = ...
    def __init__(self, coro: _CoroType[_T], seconds: float, hours: float,
                 minutes: float, count: Optional[int], reconnect: bool,
                 loop: Optional[asyncio.AbstractEventLoop]) -> None: ...
    def __get__(self: _L, obj: Any, objtype: Any) -> _L: ...
    @property
    def current_loop(self) -> int: ...
    @property
    def next_iteration(self) -> Optional[datetime.datetime]: ...
    def start(self, *args: Any, **kwargs: Any) -> asyncio.Task[_T]: ...
    def stop(self) -> None: ...
    def cancel(self) -> None: ...
    def restart(self, *args: Any, **kwargs: Any) -> None: ...
    def add_exception_type(self, *exceptions: Type[BaseException]) -> None: ...
    def clear_exception_types(self) -> None: ...
    def remove_exception_type(self, *exceptions: Type[BaseException]) -> bool: ...
    def get_task(self) -> asyncio.Task[_T]: ...
    def is_being_cancelled(self) -> bool: ...
    def failed(self) -> bool: ...
    def before_loop(self, coro: _C) -> _C: ...
    def after_loop(self, coro: _C) -> _C: ...
    def change_interval(self, *, seconds: float = ..., minutes: float = ..., hours: float = ...) -> None: ...

def loop(*, seconds: float = ..., minutes: float = ..., hours: float = ...,
         count: Optional[int] = ..., reconnect: bool = ...,
         loop: Optional[asyncio.AbstractEventLoop] = ...) -> Callable[[_CoroType[_T]], Loop[_T]]: ...
